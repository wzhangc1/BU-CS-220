# Lab09 - X86 Switch Statements

## Background

One of the more challenging translations of C instruction to X86 assembler code deals with how the gcc compiler translates a C switch statement. We discussed this in [Lecture 11](http://www.cs.binghamton.edu/~tbartens/CS220_Spring_2019/lectures/L11_x86_flow_control.pdf) on slides 17-24. Today we are going to get a chance to see how a switch statement works.

The example C program I am providing calculates a grade point average (GPA) for a college semester or career. The input to the program consists of file input read from standard input. Each line of the file represents a single course, and the data on the line contains first, the number of credit hours associated with the course (assumed to be an integer), and secondly the grade obtained for that course, where a grade is taken from the standard letter grades used in Universities, namely A, A-, B+, B, B-, C+, C, C-, D+, D, D-, F. Your grade point average is computed by assigning a number between zero and 4 to each grade, multiplying that number times the number of credit hours for that course, and dividing by the total number of credit hours. In order to avoid floating point arithmetic, the numbers associated with each grade will actually be a number between 0 and 40... ten times the actual grade number. We will divide the total result by 10.0 to get the correct GPA in the end of the calculation.

What we concentrate on for today's lab is a function within this program called `grade2gp` that translates the string that contains the grade into a number between 0 and 40. This function depends on an enumerated type, where each possible letter grade is a single value. (Since we can't put '+' and '-' in the value names, we use 'm' for minus and 'p' for plus, so, for instance, the value `Bm` represents a "B-" grade.) This function works by using a switch statement that looks at the first letter of the grade string. The first letter should always be one of 'A', 'B', 'C', 'D', or 'F'. (In this function, any uncrecognizable grade string is assumed to be an "F" grade.) Once we know the first letter, we can look at the second letter of the grade string. If the second letter is a null terminator, then there is no minus or plus... the grade is just the raw grade value. Otherwise, we look to see if the second letter is a '+' or '-' to determine the grade. We keep the grade value as an enumerated type in a variable called `gr`.

Once the `gr` value has been calculated, the `grade2gp` function has a very simple select statement that returns the numeric value between zero and 40 that is associated with that grade.

## Files Provided to You

The lab09 repository comes with several files provided for you, as follows:

- **gpa.c** : This file contains a `main` function which reads standard input, accumulates grade points and credit hours, and computes and prints the resulting GPA. It also contains the `grade2gp` function described above, which is invoked by the main funciton. Please do not modify this file. The questions you need to answer for this lab assume you have compiled unmodified code in gpa.c. Feel free to look at the code and get an idea of what is going on.

- **Makefile** : A file to provide rules for the make command. The Makefile contains rules to create the gpa binary executable file, as well `gpa.s` to dump that file using the `objdump` command to see the X86 assembler generated by the compiler. Since the gpa binary was generated with the -g flag, it has debug information which enables objdump to intersperse the C lines of code as comments in the X86 assembler output, so you can follow what is going on. The Makefile has a `test` target that runs the gpa code on an input file called transcript.txt, which is redirected to standard input; a `gdb` target to run gdb on gpa, and a `rodata` target which dumps the read only data section of the gpa binary command (something we haven't seen before, but we need for this lab.)

- **gdb_cmds.txt** : A file which contains gdb commands to be run after loading the gpa executable file under gdb, used in the Makefile for the `gdb` target.

- **transcript.txt** : A file which contains an example student transcript in the format expected by the gpa binary. (The student is farily average, and has a GPA of 2.1)

- **lab09_questions.txt** : A file which contains a list of questions. For this lab, you should edit this file and provide the answers to the questions in this text file.

## What's in a Binary Executable File?

So far, we have only talked about the x86 binary instructions that are contained in a binary executable file. It turns out that in order to make everything work, we need a lot more than just the instructions. We need to know the literal (read-only) values that are used by the instructions. We need to know the debug information if the code was compiled with the -g option. We need to know where the global data resides if our program has global data. And the list goes on.

The `objdump` command reads all these different sections of the binary executable file, and turns them into a (more or less) readable format. We use parameters to the `objdump` command to tell it what parts of the binary file we are interested in. So far, we have only used the `d` parameters to tell the objdump to find the x86 instruction section of the binary file, and run a disassembly process on those binary instructions to print out the results we see in (for example) gpa.s.

In today's lab, the compiler generates a table for us. That table is kept in the read-only data section of the binary file. Once the compiler has figured out what should be in the table, we don't want that table modified at run time, so the compiler puts the table in the "read only" data.

If you look at question 5 in lab09_questions.txt, you will see that I have reformated that table, and printed it out in a much easier to read format to save you time. You can see the real table by running `make rodata`, which invokes objdump with the parameters required to dump the read-only data section of the gpa binary file. However, the result of this invocation of objump is still hard to read because it dumps all the read-only data, not just the table of interest, and because it dumps the data in a little endian format, so we need to convert it back to big-endian to make sense of it. I've done all this work for you today to save time. Just look at the table in question 5.D in lab09_questions.txt

## Working the Lab

After you have cloned your repository, run `make gpa.s`. and edit the result along with lab09_questions.txt. Start answering the questions in lab09_questions.txt. If you get stuck, try running `make gdb` and running under gdb to see what is going on. (You may want to modify the commands in gdb_cmds.txt to work on a specific problem.)

When the questions in lab09_questions.txt ask "what value was put in %rdi" (or some similar register), please specify your answer in terms of the variables in the C code, or as C expressions which use the relevant C variables.

## Submitting the Lab

One you have answered all the questions in **lab09_questions.txt**, save the file with your answers, commit the changes to the file, and push those changes to the cloud. Cut and paste the resulting hashCode into the Lab 09 submission area in the Lab Submissions folder under Content for CS-220 in myCourses. You may submit as many times as you wish up to the deadline of midnight tonight (Apr. 2), only the last submission will be graded.

## Grading your Submission

Each numbered question in **lab09_questions.txt** counts for two points. Any sub-question answered incorrectly will result in a one-point deduction. If more than half of the sub-questions are answered incorrectly, two points will be deducted.
